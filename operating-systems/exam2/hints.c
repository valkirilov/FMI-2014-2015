#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
 
#include <unistd.h>
#include <stdio.h>
// Прави връзка между указания файл и процеса, които се идентифицира чрез файловия дескриптор
// return file descriptor
// path - пътя до файла
// oflag -
// O_RDONLY - само за четене
// O_WRONLY - за писане
// O_RDWR - за писане и четене
// O_CREAT - ако файла не съществува го създава
// O_EXCL - заедно с O_CREAT - ако файла съществува връща грешка
// O_TRUNC - ако файла съществува и се отваря за писане го изпразва
// O_APPEND - файла се отваря се добавя след края на файла
// O_SYNC -
// Ако няма файл го създава
int open(const char *path, int oflag, [, mode t_mode]);
 
// ако съществува такъв файл то то се презаписв, ако има право за писане
int creat(const char *path, mode t_mode);
 
// fildes - файлов дескриптор
int close(int fildes);
 
// Чете count байта от файла в buf идентфициран от fd, като започва четене от текущата позиция
// Прочетените байтове се записват в буфера
// Връща действителния брой прочетени байта
// Връща 0, aко текущата позиция е след EOF
// Връща -1 при грешка
ssize_t read (int fd, void *buf, size_t count);
 
// Записва count байта, от областта на процеса с адрес buf към файла от файлов дескриптор
// Започва от текущата позиция, като се увеличава с броя записани байтове
// Ако е вдигната флага O_APPEND, то текущата позиция ще сочи към края на файла
ssize_t write(int fd, const *buf, size_t count);
 
// Премества текущата позиция за файла
// offset - задава нова позиция
// flag - задава от къде 0 - от началото на файла, 1 от текущата позиция, 2 от края на файла
// ако позицията е след края на файла - то размера на файла не се увеличава
off_t lseek(int fd, off_t offset, int flag);
 
// Създава нов процес. Новия процес(child process) е точно копие на викащия го (parent process)
// Пази номера и файловия дескрипор на викащия го процес
// Новия процес има уникален номер, който не съвпада с никои друг от процесите в групата
// При успех процеса баща връща pid на процеса син
pid_t fork(void);
 
 
// wait - изчаква завършването на процес син
// Чака смяна на статуса на процеса
// Фунцкията wait ще прекрати изпълнението на нишката докато не получи информация
// за приключил процес син
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait (int *status);
pid_t waitpid(pid_t pid, int *stat_loc, int options);
 
// Изпълнява примитива close за всички отворени файлове
// Освобождава паметта заета от процеса
// Регистрира процеса като завършен и саписва кода на завършване в таблицата за процесите
// Урежда изключването на процеса от йерархията на процесите
#include <stdlib.h>
void exit(int status);
 
 
// Връща идентификатор на текущия процес
pid_t getpid(void);
 
// Връща идентификатора на процеса баща
pid_t getppid(void);
 
// execl, execv, execvp, execlp - изпълнява файл
// path - пътя към файла, който да се изпълни
// при execlp не е нужно да се задава пътя към файла а само името на програмата
int execl(const char *path, const char *arg, ..);
int execlp(const char* path, const char *arg, ..);
 
// execv и execvp има масив указател към масив от команди
// При execv се задава пътя към програмата, а при execvp само името
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
 
// Извежда съобщение на стандартния изход за грешки
#include <stdio.h>
void perror(const char *s);
 
// Външна променлива съдържаща кода на последната възникнала грешка
#include <errno.h>
int errno